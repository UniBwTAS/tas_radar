/* Generated by DBCC, see <https://github.com/howerj/dbcc> */
#include "umrr.h"
#include <inttypes.h>
#include <assert.h>

#define UNUSED(X) ((void)(X))

static inline uint64_t reverse_byte_order(uint64_t x) {
	x = (x & 0x00000000FFFFFFFF) << 32 | (x & 0xFFFFFFFF00000000) >> 32;
	x = (x & 0x0000FFFF0000FFFF) << 16 | (x & 0xFFFF0000FFFF0000) >> 16;
	x = (x & 0x00FF00FF00FF00FF) << 8  | (x & 0xFF00FF00FF00FF00) >> 8;
	return x;
}

static inline int print_helper(int r, int print_return_value) {
	return ((r >= 0) && (print_return_value >= 0)) ? r + print_return_value : -1;
}

static int pack_can_0x400_RAW_HEADER(can_obj_umrr_header_h_t *o, uint64_t *data) {
	assert(o);
	assert(data);
	register uint64_t x;
	register uint64_t i = 0;
	/* CYCLE_COUNTER: start-bit 15, length 32, endianess intel, scaling 1, offset 0 */
	x = ((uint32_t)(o->can_0x400_RAW_HEADER.CYCLE_COUNTER)) & 0xffffffff;
	x <<= 15; 
	i |= x;
	/* CYCLE_DURATION: start-bit 0, length 12, endianess intel, scaling 0.064, offset 0 */
	x = ((uint16_t)(o->can_0x400_RAW_HEADER.CYCLE_DURATION)) & 0xfff;
	i |= x;
	/* NUMBER_OF_OBJECTS: start-bit 47, length 8, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(o->can_0x400_RAW_HEADER.NUMBER_OF_OBJECTS)) & 0xff;
	x <<= 47; 
	i |= x;
	*data = (i);
	o->can_0x400_RAW_HEADER_tx = 1;
	return 0;
}

static int unpack_can_0x400_RAW_HEADER(can_obj_umrr_header_h_t *o, uint64_t data, uint8_t dlc, dbcc_time_stamp_t time_stamp) {
	assert(o);
	assert(dlc <= 8);
	register uint64_t x;
	register uint64_t i = (data);
	if (dlc < 8)
		return -1;
	/* CYCLE_COUNTER: start-bit 15, length 32, endianess intel, scaling 1, offset 0 */
	x = (i >> 15) & 0xffffffff;
	o->can_0x400_RAW_HEADER.CYCLE_COUNTER = x;
	/* CYCLE_DURATION: start-bit 0, length 12, endianess intel, scaling 0.064, offset 0 */
	x = i & 0xfff;
	o->can_0x400_RAW_HEADER.CYCLE_DURATION = x;
	/* NUMBER_OF_OBJECTS: start-bit 47, length 8, endianess intel, scaling 1, offset 0 */
	x = (i >> 47) & 0xff;
	o->can_0x400_RAW_HEADER.NUMBER_OF_OBJECTS = x;
	o->can_0x400_RAW_HEADER_rx = 1;
	o->can_0x400_RAW_HEADER_time_stamp_rx = time_stamp;
	return 0;
}

int decode_can_0x400_CYCLE_COUNTER(const can_obj_umrr_header_h_t *o, uint32_t *out) {
	assert(o);
	assert(out);
	uint32_t rval = (uint32_t)(o->can_0x400_RAW_HEADER.CYCLE_COUNTER);
	*out = rval;
	return 0;
}

int encode_can_0x400_CYCLE_COUNTER(can_obj_umrr_header_h_t *o, uint32_t in) {
	assert(o);
	o->can_0x400_RAW_HEADER.CYCLE_COUNTER = in;
	return 0;
}

int decode_can_0x400_CYCLE_DURATION(const can_obj_umrr_header_h_t *o, double *out) {
	assert(o);
	assert(out);
	double rval = (double)(o->can_0x400_RAW_HEADER.CYCLE_DURATION);
	rval *= 0.064;
	*out = rval;
	return 0;
}

int encode_can_0x400_CYCLE_DURATION(can_obj_umrr_header_h_t *o, double in) {
	assert(o);
	in *= 15.625;
	o->can_0x400_RAW_HEADER.CYCLE_DURATION = in;
	return 0;
}

int decode_can_0x400_NUMBER_OF_OBJECTS(const can_obj_umrr_header_h_t *o, uint8_t *out) {
	assert(o);
	assert(out);
	uint8_t rval = (uint8_t)(o->can_0x400_RAW_HEADER.NUMBER_OF_OBJECTS);
	*out = rval;
	return 0;
}

int encode_can_0x400_NUMBER_OF_OBJECTS(can_obj_umrr_header_h_t* o, uint8_t in) {
	assert(o);
	o->can_0x400_RAW_HEADER.NUMBER_OF_OBJECTS = in;
	return 0;
}

int print_can_0x400_RAW_HEADER(const can_obj_umrr_header_h_t *o, FILE *output) {
	assert(o);
	assert(output);
	int r = 0;
	r = print_helper(r, fprintf(output, "CYCLE_COUNTER = (wire: %.0f)\n", (double)(o->can_0x400_RAW_HEADER.CYCLE_COUNTER)));
	r = print_helper(r, fprintf(output, "CYCLE_DURATION = (wire: %.0f)\n", (double)(o->can_0x400_RAW_HEADER.CYCLE_DURATION)));
	r = print_helper(r, fprintf(output, "NUMBER_OF_OBJECTS = (wire: %.0f)\n", (double)(o->can_0x400_RAW_HEADER.NUMBER_OF_OBJECTS)));
	return r;
}

static int pack_can_0x401_TARGET_DATA_1(can_obj_umrr_target_h_t *o, uint64_t *data) {
	assert(o);
	assert(data);
	register uint64_t x;
	register uint64_t i = 0;
	/* MODE_SIGNAL: start-bit 0, length 1, endianess intel, scaling 1, offset 0 */
	x = ((uint8_t)(o->can_0x401_TARGET_DATA_1.MODE_SIGNAL)) & 0x1;
	i |= x;
	switch (o->can_0x401_TARGET_DATA_1.MODE_SIGNAL) {
	case 0:
		/* RANGE: start-bit 1, length 13, endianess intel, scaling 0.04, offset 0 */
		x = ((uint16_t)(o->can_0x401_TARGET_DATA_1.RANGE)) & 0x1fff;
		x <<= 1; 
		i |= x;
		/* SPEED_RADIAL: start-bit 39, length 12, endianess intel, scaling 0.04, offset -119.68 */
		x = ((uint16_t)(o->can_0x401_TARGET_DATA_1.SPEED_RADIAL)) & 0xfff;
		x <<= 39; 
		i |= x;
		/* AZIMUTH: start-bit 22, length 10, endianess intel, scaling 0.16, offset -81.76 */
		x = ((uint16_t)(o->can_0x401_TARGET_DATA_1.AZIMUTH)) & 0x3ff;
		x <<= 22; 
		i |= x;
		/* MODE_SIGNAL: start-bit 0, length 1, endianess intel, scaling 1, offset 0 */
		x = ((uint8_t)(o->can_0x401_TARGET_DATA_1.MODE_SIGNAL)) & 0x1;
		i |= x;
		break;
	case 1:
		/* ELEVATION: start-bit 37, length 10, endianess intel, scaling 0.04, offset -20.44 */
		x = ((uint16_t)(o->can_0x401_TARGET_DATA_1.ELEVATION)) & 0x3ff;
		x <<= 37; 
		i |= x;
		/* RCS: start-bit 1, length 8, endianess intel, scaling 0.2, offset -15 */
		x = ((uint8_t)(o->can_0x401_TARGET_DATA_1.RCS)) & 0xff;
		x <<= 1; 
		i |= x;
		break;
	default:
		return -1;
	}
	*data = (i);
	o->can_0x401_TARGET_DATA_1_tx = 1;
	return 0;
}

static int unpack_can_0x401_TARGET_DATA_1(can_obj_umrr_target_h_t *o, uint64_t data, uint8_t dlc, dbcc_time_stamp_t time_stamp) {
	assert(o);
	assert(dlc <= 8);
	register uint64_t x;
	register uint64_t i = (data);
	if (dlc < 8)
		return -1;
	/* MODE_SIGNAL: start-bit 0, length 1, endianess intel, scaling 1, offset 0 */
	x = i & 0x1;
	o->can_0x401_TARGET_DATA_1.MODE_SIGNAL = x;
	switch (o->can_0x401_TARGET_DATA_1.MODE_SIGNAL) {
	case 0:
		/* RANGE: start-bit 1, length 13, endianess intel, scaling 0.04, offset 0 */
		x = (i >> 1) & 0x1fff;
		o->can_0x401_TARGET_DATA_1.RANGE = x;
		/* SPEED_RADIAL: start-bit 39, length 12, endianess intel, scaling 0.04, offset -119.68 */
		x = (i >> 39) & 0xfff;
		o->can_0x401_TARGET_DATA_1.SPEED_RADIAL = x;
		/* AZIMUTH: start-bit 22, length 10, endianess intel, scaling 0.16, offset -81.76 */
		x = (i >> 22) & 0x3ff;
		o->can_0x401_TARGET_DATA_1.AZIMUTH = x;
		/* MODE_SIGNAL: start-bit 0, length 1, endianess intel, scaling 1, offset 0 */
		x = i & 0x1;
		o->can_0x401_TARGET_DATA_1.MODE_SIGNAL = x;
		break;
	case 1:
		/* ELEVATION: start-bit 37, length 10, endianess intel, scaling 0.04, offset -20.44 */
		x = (i >> 37) & 0x3ff;
		o->can_0x401_TARGET_DATA_1.ELEVATION = x;
		/* RCS: start-bit 1, length 8, endianess intel, scaling 0.2, offset -15 */
		x = (i >> 1) & 0xff;
		o->can_0x401_TARGET_DATA_1.RCS = x;
		break;
	default:
		return -1;
	}
	o->can_0x401_TARGET_DATA_1_rx = 1;
	o->can_0x401_TARGET_DATA_1_time_stamp_rx = time_stamp;
	return 0;
}

int decode_can_0x401_RANGE(const can_obj_umrr_target_h_t* o, double *out) {
	assert(o);
	assert(out);
	double rval = (double)(o->can_0x401_TARGET_DATA_1.RANGE);
	rval *= 0.04;
	if (rval <= 327.64) {
		*out = rval;
		return 0;
	} else {
		*out = (double)0;
		return -1;
	}
}

int encode_can_0x401_RANGE(can_obj_umrr_target_h_t* o, double in) {
	assert(o);
	o->can_0x401_TARGET_DATA_1.RANGE = 0;
	if (in > 327.64)
		return -1;
	in *= 25;
	o->can_0x401_TARGET_DATA_1.RANGE = in;
	return 0;
}

int decode_can_0x401_SPEED_RADIAL(const can_obj_umrr_target_h_t* o, double *out) {
	assert(o);
	assert(out);
	double rval = (double)(o->can_0x401_TARGET_DATA_1.SPEED_RADIAL);
	rval *= 0.04;
	rval += -119.68;
	if (rval <= 44.12) {
		*out = rval;
		return 0;
	} else {
		*out = (double)0;
		return -1;
	}
}

int encode_can_0x401_SPEED_RADIAL(can_obj_umrr_target_h_t* o, double in) {
	assert(o);
	o->can_0x401_TARGET_DATA_1.SPEED_RADIAL = 0;
	if (in > 44.12)
		return -1;
	in += 119.68;
	in *= 25;
	o->can_0x401_TARGET_DATA_1.SPEED_RADIAL = in;
	return 0;
}

int decode_can_0x401_AZIMUTH(const can_obj_umrr_target_h_t* o, double *out) {
	assert(o);
	assert(out);
	double rval = (double)(o->can_0x401_TARGET_DATA_1.AZIMUTH);
	rval *= 0.16;
	rval += -81.76;
	if (rval <= 81.92) {
		*out = rval;
		return 0;
	} else {
		*out = (double)0;
		return -1;
	}
}

int encode_can_0x401_AZIMUTH(can_obj_umrr_target_h_t *o, double in) {
	assert(o);
	o->can_0x401_TARGET_DATA_1.AZIMUTH = 0;
	if (in > 81.92)
		return -1;
	in += 81.76;
	in *= 6.25;
	o->can_0x401_TARGET_DATA_1.AZIMUTH = in;
	return 0;
}

int decode_can_0x401_MODE_SIGNAL(const can_obj_umrr_target_h_t* o, uint8_t *out) {
	assert(o);
	assert(out);
	uint8_t rval = (uint8_t)(o->can_0x401_TARGET_DATA_1.MODE_SIGNAL);
	*out = rval;
	return 0;
}

int encode_can_0x401_MODE_SIGNAL(can_obj_umrr_target_h_t *o, uint8_t in) {
	assert(o);
	o->can_0x401_TARGET_DATA_1.MODE_SIGNAL = in;
	return 0;
}

int decode_can_0x401_ELEVATION(const can_obj_umrr_target_h_t* o, double *out) {
	assert(o);
	assert(out);
	double rval = (double)(o->can_0x401_TARGET_DATA_1.ELEVATION);
	rval *= 0.04;
	rval += -20.44;
	if (rval <= 20.48) {
		*out = rval;
		return 0;
	} else {
		*out = (double)0;
		return -1;
	}
}

int encode_can_0x401_ELEVATION(can_obj_umrr_target_h_t* o, double in) {
	assert(o);
	o->can_0x401_TARGET_DATA_1.ELEVATION = 0;
	if (in > 20.48)
		return -1;
	in += 20.44;
	in *= 25;
	o->can_0x401_TARGET_DATA_1.ELEVATION = in;
	return 0;
}

int decode_can_0x401_RCS(const can_obj_umrr_target_h_t* o, double *out) {
	assert(o);
	assert(out);
	double rval = (double)(o->can_0x401_TARGET_DATA_1.RCS);
	rval *= 0.2;
	rval += -15;
	if (rval <= 36) {
		*out = rval;
		return 0;
	} else {
		*out = (double)0;
		return -1;
	}
}

int encode_can_0x401_RCS(can_obj_umrr_target_h_t* o, double in) {
	assert(o);
	o->can_0x401_TARGET_DATA_1.RCS = 0;
	if (in > 36)
		return -1;
	in += 15;
	in *= 5;
	o->can_0x401_TARGET_DATA_1.RCS = in;
	return 0;
}

int print_can_0x401_TARGET_DATA_1(const can_obj_umrr_target_h_t *o, FILE *output) {
	assert(o);
	assert(output);
	int r = 0;
	r = print_helper(r, fprintf(output, "RANGE = (wire: %.0f)\n", (double)(o->can_0x401_TARGET_DATA_1.RANGE)));
	r = print_helper(r, fprintf(output, "SPEED_RADIAL = (wire: %.0f)\n", (double)(o->can_0x401_TARGET_DATA_1.SPEED_RADIAL)));
	r = print_helper(r, fprintf(output, "AZIMUTH = (wire: %.0f)\n", (double)(o->can_0x401_TARGET_DATA_1.AZIMUTH)));
	r = print_helper(r, fprintf(output, "MODE_SIGNAL = (wire: %.0f)\n", (double)(o->can_0x401_TARGET_DATA_1.MODE_SIGNAL)));
	r = print_helper(r, fprintf(output, "ELEVATION = (wire: %.0f)\n", (double)(o->can_0x401_TARGET_DATA_1.ELEVATION)));
	r = print_helper(r, fprintf(output, "RCS = (wire: %.0f)\n", (double)(o->can_0x401_TARGET_DATA_1.RCS)));
	return r;
}

int unpack_message_header(can_obj_umrr_header_h_t *o, const unsigned long id, uint64_t data, uint8_t dlc, dbcc_time_stamp_t time_stamp) {
	assert(o);
	assert(id < (1ul << 29)); /* 29-bit CAN ID is largest possible */
	assert(dlc <= 8);         /* Maximum of 8 bytes in a CAN packet */
	switch (id) {
	case 0x400: return unpack_can_0x400_RAW_HEADER(o, data, dlc, time_stamp);

	default: break; 
	}
	return -1; 
}

int pack_message_header(can_obj_umrr_header_h_t *o, const unsigned long id, uint64_t *data) {
	assert(o);
	assert(id < (1ul << 29)); /* 29-bit CAN ID is largest possible */
	switch (id) {
	case 0x400: return pack_can_0x400_RAW_HEADER(o, data);

	default: break; 
	}
	return -1; 
}

int print_message_header(const can_obj_umrr_header_h_t *o, const unsigned long id, FILE *output) {
	assert(o);
	assert(id < (1ul << 29)); /* 29-bit CAN ID is largest possible */
	assert(output);
	switch (id) {
	case 0x400: return print_can_0x400_RAW_HEADER(o, output);

	default: break; 
	}
	return -1; 
}

uint64_t u64_from_can_msg(const uint8_t m[8]) {
	return ((uint64_t)m[7] << 56) | ((uint64_t)m[6] << 48) | ((uint64_t)m[5] << 40) | ((uint64_t)m[4] << 32) 
		| ((uint64_t)m[3] << 24) | ((uint64_t)m[2] << 16) | ((uint64_t)m[1] << 8) | ((uint64_t)m[0] << 0);
}

void u64_to_can_msg(const uint64_t u, uint8_t m[8]) {
	m[7] = u >> 56;
	m[6] = u >> 48;
	m[5] = u >> 40;
	m[4] = u >> 32;
	m[3] = u >> 24;
	m[2] = u >> 16;
	m[1] = u >>  8;
	m[0] = u >>  0;
}

int unpack_message_target(can_obj_umrr_target_h_t *o, const unsigned long id, uint64_t data, uint8_t dlc, dbcc_time_stamp_t time_stamp) {
    assert(o);
    assert(id < (1ul << 29)); /* 29-bit CAN ID is largest possible */
    assert(dlc <= 8);         /* Maximum of 8 bytes in a CAN packet */
    switch (id) {
        case 0x401: return unpack_can_0x401_TARGET_DATA_1(o, data, dlc, time_stamp);

        default: break;
    }
    return -1;
}

int pack_message_target(can_obj_umrr_target_h_t *o, const unsigned long id, uint64_t *data) {
    assert(o);
    assert(id < (1ul << 29)); /* 29-bit CAN ID is largest possible */
    switch (id) {
        case 0x401: return pack_can_0x401_TARGET_DATA_1(o, data);

        default: break;
    }
    return -1;
}

int print_message_target(const can_obj_umrr_target_h_t *o, const unsigned long id, FILE *output) {
    assert(o);
    assert(id < (1ul << 29)); /* 29-bit CAN ID is largest possible */
    assert(output);
    switch (id) {
        case 0x401: return print_can_0x401_TARGET_DATA_1(o, output);

        default: break;
    }
    return -1;
}



